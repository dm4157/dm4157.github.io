<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="运行时类型信息使得你可以在程序运行时发现和使用类型信息

java运行时识别对象和类的信息主要有两种方式：

RTTI
反射

RTTI
接口与父类都是一种窗口，透过他们只能看到具体实现的一部分

RTTI(Run-Time Type Identification), 在运行时识别一个对象的类型。有了RTTI才有多态， 而多态是面向对象编程的基本目标。举个栗子1List&amp;lt;String&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="类型信息">
<meta property="og:url" content="http://dm4157.github.io/2016/03/30/java1/index.html">
<meta property="og:site_name" content="蝉羽">
<meta property="og:description" content="运行时类型信息使得你可以在程序运行时发现和使用类型信息

java运行时识别对象和类的信息主要有两种方式：

RTTI
反射

RTTI
接口与父类都是一种窗口，透过他们只能看到具体实现的一部分

RTTI(Run-Time Type Identification), 在运行时识别一个对象的类型。有了RTTI才有多态， 而多态是面向对象编程的基本目标。举个栗子1List&amp;lt;String&amp;gt">
<meta property="og:updated_time" content="2017-07-25T07:09:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="类型信息">
<meta name="twitter:description" content="运行时类型信息使得你可以在程序运行时发现和使用类型信息

java运行时识别对象和类的信息主要有两种方式：

RTTI
反射

RTTI
接口与父类都是一种窗口，透过他们只能看到具体实现的一部分

RTTI(Run-Time Type Identification), 在运行时识别一个对象的类型。有了RTTI才有多态， 而多态是面向对象编程的基本目标。举个栗子1List&amp;lt;String&amp;gt">
    
    
        
          
              <link rel="shortcut icon" href="/images/my.jpg">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/my.jpg" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/my.jpg">
          
        
    
    <!-- title -->
    <title>类型信息</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2016/04/10/angular1/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li>
        
        
        <li><a class="icon" href="/2016/03/06/talk1/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://dm4157.github.io/2016/03/30/java1/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://dm4157.github.io/2016/03/30/java1/&text=类型信息"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li class="icon bdsharebuttonbox"><a href="javascript:void(0)" data-cmd="weixin" id="wexin" class="fa fa-comments bds_weixin" aria-hidden="true"></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://dm4157.github.io/2016/03/30/java1/&title=类型信息"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=类型信息&body=Check out this article: http://dm4157.github.io/2016/03/30/java1/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI"><span class="toc-number">1.</span> <span class="toc-text">RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class"><span class="toc-number">2.</span> <span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获得Class对象的两种方式"><span class="toc-number">2.1.</span> <span class="toc-text">获得Class对象的两种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#值得注意的点"><span class="toc-number">2.2.</span> <span class="toc-text">值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断对象与类型的关系"><span class="toc-number">2.3.</span> <span class="toc-text">判断对象与类型的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-number">3.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法"><span class="toc-number">3.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理泛型"><span class="toc-number">3.2.</span> <span class="toc-text">处理泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理"><span class="toc-number">3.3.</span> <span class="toc-text">动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器"><span class="toc-number">4.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-ClassLoader"><span class="toc-number">4.2.</span> <span class="toc-text">java.lang.ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组织结构"><span class="toc-number">4.3.</span> <span class="toc-text">组织结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加载类的过程"><span class="toc-number">4.4.</span> <span class="toc-text">加载类的过程</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        类型信息
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">殇月陨</span>
      </span>
      
    <div class="postdate">
        <time datetime="2016-03-30T13:07:27.000Z" itemprop="datePublished">2016-03-30</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/class/">class</a>, <a class="tag-link" href="/tags/java/">java</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>运行时类型信息使得你可以在程序运行时发现和使用类型信息</p>
</blockquote>
<p>java运行时识别对象和类的信息主要有两种方式：</p>
<ul>
<li><code>RTTI</code></li>
<li><code>反射</code></li>
</ul>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><blockquote>
<p>接口与父类都是一种<strong>窗口</strong>，透过他们只能看到具体实现的一部分</p>
</blockquote>
<p><code>RTTI</code>(Run-Time Type Identification), 在运行时识别一个对象的类型。<br>有了<code>RTTI</code>才有<code>多态</code>， 而<code>多态</code>是面向对象编程的基本目标。<br><strong>举个栗子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lizi = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>这种写法的好处是方便替换具体实现，可能开始的时候觉得随机读取比较多就用<code>ArrayList</code>, 之后发现增删改比较多，可以简单的将实现替换为<code>LinkedList</code>即可。除非要用到具体实现的具体特性，否则一直建议使用更宽泛的类型引用。</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="获得Class对象的两种方式"><a href="#获得Class对象的两种方式" class="headerlink" title="获得Class对象的两种方式"></a>获得Class对象的两种方式</h3><ul>
<li>Class.forName(name) 获得Class对象的同时会加载类</li>
<li>XXXX.class 只获得Class对象，不会加载类。学名是类字面常量。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class.forName 方法， 找到合适的类加载器调用本地方法forName0</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                               ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    Class&lt;?&gt; caller = <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Reflective call to get caller class is only needed if a security manager</span></span><br><span class="line">        <span class="comment">// is present.  Avoid the overhead of making this call otherwise.</span></span><br><span class="line">        caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (sun.misc.VM.isSystemDomainLoader(loader)) &#123;</span><br><span class="line">            ClassLoader ccl = ClassLoader.getClassLoader(caller);</span><br><span class="line">            <span class="keyword">if</span> (!sun.misc.VM.isSystemDomainLoader(ccl)) &#123;</span><br><span class="line">                sm.checkPermission(</span><br><span class="line">                    SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从参数上就能看出来这货是要加载类了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="keyword">boolean</span> initialize, ClassLoader loader, Class&lt;?&gt; caller) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="值得注意的点"><a href="#值得注意的点" class="headerlink" title="值得注意的点"></a>值得注意的点</h3><blockquote>
<p>编译器已知的static final修饰的常量，这个值不需要进行类初始化就能访问到。<strong>为啥呢？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal = <span class="number">57</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 = ClassInitialization.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"类初始化啦"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassInitialization</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">57</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有触发类的初始化</span></span><br><span class="line">    Class initable = Initable.class;</span><br><span class="line">    <span class="comment">// 没有触发类的初始化</span></span><br><span class="line">    System.out.println(Initable.staticFinal);</span><br><span class="line">    <span class="comment">// 触发类的初始化</span></span><br><span class="line">    System.out.println(Initable.staticFinal2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 57</span></span><br><span class="line"><span class="comment">// 类初始化啦</span></span><br><span class="line"><span class="comment">// 241</span></span><br></pre></td></tr></table></figure>
<h3 id="判断对象与类型的关系"><a href="#判断对象与类型的关系" class="headerlink" title="判断对象与类型的关系"></a>判断对象与类型的关系</h3><p>判断一个对象是否是一个类型或者其类型是这个类型的子类，有两种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class type = ...;</span><br><span class="line">Object obj = ...;</span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">if</span> (obj instanceOf type) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">if</span>(type.isInstance(obj)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote>
<p>世界是平衡的</p>
</blockquote>
<p>正如英文单词reflection的含义一样，使用反射API的时候就好像在看一个Java类在水中的倒影一样。知道了Java类的内部 结构之后，就可以与它进行交互，包括创建新的对象和调用对象中的方法等。这种交互方式与直接在源代码中使用的效果是相同的，但是又额外提供了运行时刻的灵活性。使用反射的一个最大的弊端是<strong>性能比较差</strong>。相同的操作，用反射API所需的时间大概比直接的使用要慢一两个数量级。不过现在的JVM实现中，反射操作的性能已经有了很大的提升。在灵活性与性能之间，总是需要进行权衡的。应用可以在适当的时机来使用反射API。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Java反射API的第一个主要作用是获取程序在运行时刻的内部结构。只要有了java.lang.Class类的对象，就可以通过其中的方法来获取到该类中的构造方法、域和方法。对应的方法分别是getConstructor、getField和getMethod。这三个方法还有相应的getDeclaredXXX版本，区别在于getXXX只会获得“允许”访问的内容(即public修饰的)， 而getDeclaredXXX会获得所有修饰的内容；</p>
<blockquote>
<p>使用Java反射API的时候可以绕过Java默认的访问控制检查，只需要在获取到Constructor、Field和Method类的对象之后，调用setAccessible方法并设为true即可。有了这种机制，就可以很方便的在运行时刻获取到程序的内部状态。</p>
</blockquote>
<p>反射API的另外一个作用是在运行时刻对一个Java对象进行操作。 这些操作包括动态创建一个Java类的对象，获取某个域的值以及调用某个方法。在Java源代码中编写的对类和对象的操作，都可以在运行时刻通过反射API来实现。<br><strong>举个栗子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        count = start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        count = count + step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般操作</span></span><br><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass(<span class="number">0</span>);</span><br><span class="line">myClass.increase(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"Normal -&gt; "</span> + myClass.count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取构造方法</span></span><br><span class="line">    Constructor constructor = MyClass.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    MyClass myClassReflect = constructor.newInstance(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 获取方法</span></span><br><span class="line">    Method method = MyClass.class.getMethod(<span class="string">"increase"</span>, <span class="keyword">int</span>.class);  </span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    method.invoke(myClassReflect, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 获取域</span></span><br><span class="line">    Field field = MyClass.class.getField(<span class="string">"count"</span>);</span><br><span class="line">    <span class="comment">// 获取域的值</span></span><br><span class="line">    System.out.println(<span class="string">"Reflect -&gt; "</span> + field.getInt(myClassReflect));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="处理泛型"><a href="#处理泛型" class="headerlink" title="处理泛型"></a>处理泛型</h3><p>比如在代码中声明了一个域是List<string>类型的，虽然在运行时刻其类型会变成原始类型List，但是仍然可以通过反射来获取到所用的实际的类型参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Field field = Pair.class.getDeclaredField(<span class="string">"myList"</span>); <span class="comment">//myList的类型是List</span></span><br><span class="line">Type type = field.getGenericType();</span><br><span class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;     </span><br><span class="line">    ParameterizedType paramType = (ParameterizedType) type;     </span><br><span class="line">    Type[] actualTypes = paramType.getActualTypeArguments();     </span><br><span class="line">    <span class="keyword">for</span> (Type aType : actualTypes) &#123;         </span><br><span class="line">        <span class="keyword">if</span> (aType <span class="keyword">instanceof</span> Class) &#123;         </span><br><span class="line">            Class clz = (Class) aType;             </span><br><span class="line">            System.out.println(clz.getName()); <span class="comment">//输出java.lang.String         </span></span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>下面的代码用来代理一个实现了List接口的对象。所实现的功能也非常简单，那就是禁止使用List接口中的add方法。如果在getList中传入一个实现List接口的对象，那么返回的实际就是一个代理对象，尝试在该对象上调用add方法就会抛出来异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getList</span><span class="params">(<span class="keyword">final</span> List list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List) Proxy.newProxyInstance(DummyProxy.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123; List.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"add"</span>.equals(method.getName())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(list, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>顾名思义，类加载器(Class Loader)用来加载类到Java虚拟机(JVM)中。一般来说，JVM使用Java类的方式如下：Java源程序(.java文件)在经过编译器编译之后就被转换成Java字节代码(.class文件)。类加载器负责读取Java字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个Java类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如Java字节代码可能是通过工具动态生成的，也可能是通过网络下载的。<br>基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。</p>
<h3 id="java-lang-ClassLoader"><a href="#java-lang-ClassLoader" class="headerlink" title="java.lang.ClassLoader"></a>java.lang.ClassLoader</h3><p>java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个Java类，即java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载Java应用所需的资源，如图像文件和配置文件等。不过本文只讨论其加载类的功能。<br>为了完成加载类的这个职责，ClassLoader提供了一系列的方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getParent()</td>
<td style="text-align:left">返回该类加载器的父类加载器。</td>
</tr>
<tr>
<td style="text-align:left">loadClass(String name)</td>
<td style="text-align:left">加载名称为name的类，返回的结果是 java.lang.Class类的实例。</td>
</tr>
<tr>
<td style="text-align:left">findClass(String name)</td>
<td style="text-align:left">查找名称为name的类，返回的结果是 java.lang.Class类的实例。</td>
</tr>
<tr>
<td style="text-align:left">findLoadedClass(String name)</td>
<td style="text-align:left">查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。</td>
</tr>
<tr>
<td style="text-align:left">defineClass(String name, byte[] b, int off, int len)</td>
<td style="text-align:left">把字节数组b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。</td>
</tr>
<tr>
<td style="text-align:left">resolveClass(Class&lt;?&gt; c)</td>
<td style="text-align:left">链接指定的Java类。</td>
</tr>
</tbody>
</table>
<h3 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h3><p>Java中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由Java应用开发人员编写的。系统提供的类加载器主要有下面三个：</p>
<ul>
<li>引导类加载器(bootstrap class loader)：它用来加载Java的核心库，是用原生代码来实现的，并不继承自java.lang.ClassLoader。</li>
<li>扩展类加载器(extensions class loader)：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器(system class loader)：它根据 Java 应用的类路径(CLASSPATH)来加载Java类。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。<br>除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示类加载组织结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ClassLoader loader = ClassLoaderTree.class.getClassLoader();</span><br><span class="line">       <span class="keyword">while</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.println(loader.toString());</span><br><span class="line">           loader = loader.getParent();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// sun.misc.Launcher$AppClassLoader@7adf9f5f</span></span><br><span class="line"><span class="comment">// sun.misc.Launcher$ExtClassLoader@5b2133b1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第一个输出的是 ClassLoaderTree类的类加载器，即系统类加载器。它是 sun.misc.Launcher$AppClassLoader类的实例；第二个输出的是扩展类加载器，是 sun.misc.Launcher$ExtClassLoader类的实例。需要注意的是这里并没有输出引导类加载器，这是由于有些JDK的实现对于父类加载器是引导类加载器的情况，getParent()方法返回null。</p>
<h3 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h3><p>类加载器首先检查这个类的Class是否已经加载，如果未加载，默认的类加载器会找到.class字节码，加载、链接、初始化；</p>
<ul>
<li><strong>加载</strong> 由类加载器执行， 查找字节码， 并根据字节码创建Class对象</li>
<li><strong>链接</strong> 验证类中的字节码，为静态域分配存储空间，并且如果必要将解析这个类对其他类的引用并创建</li>
<li><strong>初始化</strong> 如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块</li>
</ul>

  </div>
</article>

<section class="reward">
	<a class="btn-reward dashang" href="#">打赏</a>
	<div class="reward-wrapper clearfix">
		<img src="/images/dashang.png" title="微信">
	</div>
</section>


	<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTczMS82Mjk3"></div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI"><span class="toc-number">1.</span> <span class="toc-text">RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class"><span class="toc-number">2.</span> <span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获得Class对象的两种方式"><span class="toc-number">2.1.</span> <span class="toc-text">获得Class对象的两种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#值得注意的点"><span class="toc-number">2.2.</span> <span class="toc-text">值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断对象与类型的关系"><span class="toc-number">2.3.</span> <span class="toc-text">判断对象与类型的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-number">3.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法"><span class="toc-number">3.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理泛型"><span class="toc-number">3.2.</span> <span class="toc-text">处理泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理"><span class="toc-number">3.3.</span> <span class="toc-text">动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器"><span class="toc-number">4.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-ClassLoader"><span class="toc-number">4.2.</span> <span class="toc-text">java.lang.ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组织结构"><span class="toc-number">4.3.</span> <span class="toc-text">组织结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加载类的过程"><span class="toc-number">4.4.</span> <span class="toc-text">加载类的过程</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://dm4157.github.io/2016/03/30/java1/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://dm4157.github.io/2016/03/30/java1/&text=类型信息"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li class="icon bdsharebuttonbox"><a href="javascript:void(0)" data-cmd="weixin" id="wexin" class="fa fa-comments bds_weixin" aria-hidden="true"></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://dm4157.github.io/2016/03/30/java1/&title=类型信息"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=类型信息&body=Check out this article: http://dm4157.github.io/2016/03/30/java1/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2017 殇月陨
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

<!-- 来比力评论 -->
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<!-- 百度分享 -->
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-103162179-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


